# Golang调度



## 一、操作系统调度

操作系统调度器，负责确保在有线程能够运行的时候内核不会空闲下来。它必须要制造出这样一种错觉——所有能够跑的线程此时都在同时执行。为了制造这种错觉，调度器需要优先执行高优先级的线程，但是它也必须保证低优先级的线程不会饿死(永远没有执行机会)。调度器也必须通过做出更聪明的决定将调度延时尽可能的压倒最少。



### 线程状态

另一个重要概念就是“线程状态”，线程状态说明了调度器该如何处理此时的线程。线程有三个状态:等待、可运行、执行中。

##### 等待(Waiting)：

此时意味着线程停止并且等待被唤醒。可能发生的原因有，等待硬件(硬盘、网络)，操作系统(系统调用) 或者是同步调用(atomic,mutexes)。这些情况是导致性能问题的根源

##### 可运行(Runnable)：

此时线程想要占用内核上的cpu时间来执行分配给线程的指令。如果你有许多线程想要cpu时间，线程必须要等一段时间才能取到cpu时间。随着更多线程争用cpu时间，线程分配的cpu时间会更短。这种情况下的调度延时也会造成性能问题。

##### 执行中(Executing):

此时线程已经置于内核中，并且正在执行它的机器指令。应用程序的相关内容正在被处理。这种状态是我们所希望的。



### 线程工作类型

##### CPU密集型(cpu-bound):

这种工作下，线程永远不会被置换到等待(waiting)状态。这种一般是进行持续性的cpu计算工作。比如计算Pi这种的就是cpu密集型工作

##### IO密集型(io-bound)

这种工作会让线程进入到等待(waiting)状态。这种情况线程会持续的请求资源（比如网络资源）或者是对操作系统进行系统调用。线程需要访问数据库的情况就是IO密集型工作。同时我会把同步事件(例如mutexes、atomic)，这种需要线程等待的情况归入此类工作。







## 参考资料

- [理解golang调度之一 ：操作系统调度](https://juejin.im/post/5cdeb6cdf265da1bd605727f)
- [理解golang调度之二 ：Go调度器](https://juejin.im/post/5ce11a39f265da1baf7cbc61)
- [理解golang调度之三:并发](https://juejin.im/post/5ce2a17fe51d45105e02120b)
- [golang面试题分析03_GMP调度器](https://blog.csdn.net/weixin_43851310/article/details/88933278)
- [Go语言高阶：调度器系列（1）起源](https://mp.weixin.qq.com/s/p7sqYBUZngMfU3xXf9TNWA)